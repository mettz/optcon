##################################
        # ARMIJO IMPLEMENTATION
        ##################################
 
        ##################################
        # Descent direction calculation
        ##################################
        lmbd_temp = cst.termcost(xx_opt[:,TT-1], xx_ref[:,TT-1])[1]
        lmbd[:,TT-1,kk] = lmbd_temp.squeeze()
 
        for tt in reversed(range(TT-1)):
            lmbd_temp = AA[:,:,tt].T@lmbd[:,tt+1,kk] + qq[:,tt]
            dJ_temp = BB[:,:,tt].T@lmbd[:,tt+1,kk] + rr[:,tt]
 
            lmbd[:,tt,kk] = lmbd_temp.squeeze()
            dJ[:,tt,kk] = dJ_temp.squeeze()
 
            descent[kk] += delta_u[:,tt].T@delta_u[:,tt]
            descent_arm[kk] += dJ[:,tt,kk].T@delta_u[:,tt]
 
        ##################################
        # Stepsize selection with Armijo
        ##################################
        stepsizes = []
        costs_armijo = []
 
        stepsize = stepsize_0
 
        for ii in range(armijo_maxiters):
            xx_temp = np.zeros((ns,TT))
            uu_temp = np.zeros((nu,TT))
 
            xx_temp[:,0] = xx_ref[:,0]
 
            for tt in range(TT-1):
                uu_temp[:,tt] = uu_opt[:,tt] + stepsize*delta_u[:,tt]
                xx_temp[:,tt+1] = dyn.dynamics(xx_temp[:,tt], uu_temp[:,tt])[0]
           
            # Tempcost computation
            JJ_temp = 0
            for tt in range(TT-1):
                JJ_temp += cst.stagecost(xx_temp[:,tt], uu_temp[:,tt], xx_ref[:,tt], uu_ref[:,tt])[0]
            JJ_temp += cst.termcost(xx_temp[:,-1], xx_ref[:,-1])[0]
 
            stepsizes.append(stepsize)
            costs_armijo.append(JJ_temp)
 
            if JJ_temp > JJ[kk] + cc*stepsize*descent_arm[kk]:
                stepsize = beta*stepsize
                # print("Armijo stepsize updated. It becomes stepsize = {}".format(stepsize))
            else:
                # print("Armijo stepsize not updated. It remains stepsize = {}".format(stepsize))
                break
       
        if visu_armijo and kk%10==0:
            steps = np.linspace(0,stepsize_0, int(2e1))
            costs = np.zeros(len(steps))
            for ii in range(len(steps)):
                step = steps[ii]
                xx_temp = np.zeros((ns,TT))
                uu_temp = np.zeros((nu,TT))
                xx_temp[:,0] = xx_ref[:,0]
 
                for tt in range(TT-1):
                    uu_temp[:,tt] = uu_opt[:,tt] + step*delta_u[:,tt]
                    xx_temp[:,tt+1] = dyn.dynamics(xx_temp[:,tt], uu_temp[:,tt])[0]
               
                JJ_temp = 0
 
                for tt in range(TT-1):
                    JJ_temp += cst.stagecost(xx_temp[:,tt], uu_temp[:,tt], xx_ref[:,tt], uu_ref[:,tt])[0]
                JJ_temp += cst.termcost(xx_temp[:,-1], xx_ref[:,-1])[0]
 
                costs[ii] = JJ_temp
           
            plt.figure(1)
            plt.clf()
            plt.plot(steps, costs, color='g', label='$J(\\mathbf{u}^k - stepsize*d^k)$')
            plt.plot(steps, JJ[kk] + descent_arm[kk]*steps, color='r', label='$J(\\mathbf{u}^k) - stepsize*\\nabla J(\\mathbf{u}^k)^{\\top} d^k$')
            plt.plot(steps, JJ[kk] + cc*descent_arm[kk]*steps, color='g', linestyle='dashed', label='$J(\\mathbf{u}^k) - stepsize*c*\\nabla J(\\mathbf{u}^k)^{\\top} d^k$')
            plt.scatter(stepsizes, costs_armijo, marker='*', color="k") # plot the tested stepsize
            plt.grid()
            plt.xlabel("stepsize")
            plt.legend()
            plt.draw()
            plt.show()
